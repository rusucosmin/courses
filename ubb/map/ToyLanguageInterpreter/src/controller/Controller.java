package controller;import exception.*;import javafx.beans.property.SimpleStringProperty;import javafx.beans.value.ChangeListener;import javafx.beans.value.ObservableValue;import javafx.collections.FXCollections;import javafx.collections.ObservableList;import javafx.fxml.FXML;import javafx.scene.control.*;import javafx.scene.layout.GridPane;import javafx.scene.layout.Priority;import javafx.util.Callback;import model.*;import repository.IRepository;import services.PrgStateService;import utils.Observable;import java.io.FileNotFoundException;import java.io.IOException;import java.io.PrintWriter;import java.io.StringWriter;import java.util.*;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.stream.Collector;import java.util.stream.Collectors;/** * Created by cosmin on 10/25/16. */public class Controller implements utils.Observer<PrgState> {    @FXML    private Label prgStatesCnt;    @FXML    private TableView<Map.Entry<Integer, Integer>> heapTableView;    @FXML    private ListView<String> outListView;    @FXML    private TableView<Tuple<Integer, String>> fileTableView;    @FXML    private TableView<Tuple<Integer, Integer>> latchTableView;    @FXML    private ListView<PrgState> prgStateListView;    @FXML    private Label prgIdLabel;    @FXML    private TableView<Tuple<String, Integer>> symTableView;    @FXML    private ListView<IStmt> exeStackListView;    private IRepository rep;    private ObservableList<PrgState> prgStateModel;    private ObservableList<String> outListModel;    private ObservableList<Map.Entry<Integer, Integer>> heapTableModel;    private ObservableList<Tuple<Integer, String>> fileTableModel;    private ObservableList<Tuple<Integer, Integer>> latchTableModel;    private ObservableList<IStmt> exeStackModel;    private ExecutorService executor;    private PrgStateService prgStateService;    private ObservableList<Tuple<String, Integer>> symTableModel;    public Controller() {    }    @FXML    private void initialize() {    }    public void setService(PrgStateService prgStateService) {        this.prgStateService = prgStateService;        this.rep = this.prgStateService.getRepo();        //prg state model;        this.prgStateModel = FXCollections.observableArrayList();        this.prgStateListView.setItems(this.prgStateModel);        this.prgStateListView.setCellFactory(new Callback<ListView<PrgState>, ListCell<PrgState>>() {            @Override            public ListCell<PrgState> call(ListView<PrgState> param) {                ListCell<PrgState> listCell = new ListCell<PrgState>() {                    @Override                    protected void updateItem(PrgState e, boolean empty) {                        super.updateItem(e, empty);                        if (e == null || empty)                            setText("");                        else                            setText(String.valueOf(e.getId()));                    }                };                return listCell;            }        });        // heapTableView        this.heapTableModel = FXCollections.observableArrayList();        TableColumn<Map.Entry<Integer, Integer>, String> first = new TableColumn<>("Address");        TableColumn<Map.Entry<Integer, Integer>, String> second = new TableColumn<>("Value");        first.setCellValueFactory(new Callback<TableColumn.CellDataFeatures<Map.Entry<Integer, Integer>, String>, ObservableValue<String>>() {            @Override            public ObservableValue<String> call(TableColumn.CellDataFeatures<Map.Entry<Integer, Integer>, String> param) {                return new SimpleStringProperty(String.valueOf(param.getValue().getKey()));            }        });        second.setCellValueFactory(new Callback<TableColumn.CellDataFeatures<Map.Entry<Integer, Integer>, String>, ObservableValue<String>>() {            @Override            public ObservableValue<String> call(TableColumn.CellDataFeatures<Map.Entry<Integer, Integer>, String> param) {                return new SimpleStringProperty(String.valueOf(param.getValue().getValue()));            }        });        this.heapTableView.getColumns().setAll(first, second);        this.heapTableView.setItems(this.heapTableModel);        /// latchTAbleView        this.latchTableModel = FXCollections.observableArrayList();        TableColumn<Tuple<Integer, Integer>, String> latchId = new TableColumn<>("LatchID");        TableColumn<Tuple<Integer, Integer>, String> latchCount = new TableColumn<>("LatchCNT");        latchId.setCellValueFactory(new Callback<TableColumn.CellDataFeatures<Tuple<Integer, Integer>, String>, ObservableValue<String>>() {            @Override            public ObservableValue<String> call(TableColumn.CellDataFeatures<Tuple<Integer, Integer>, String> param) {                return new SimpleStringProperty(String.valueOf(param.getValue().getFirst()));            }        });        latchCount.setCellValueFactory(new Callback<TableColumn.CellDataFeatures<Tuple<Integer, Integer>, String>, ObservableValue<String>>() {            @Override            public ObservableValue<String> call(TableColumn.CellDataFeatures<Tuple<Integer, Integer>, String> param) {                return new SimpleStringProperty(String.valueOf(param.getValue().getSecond()));            }        });        this.latchTableView.getColumns().setAll(latchId, latchCount);        this.latchTableView.setItems(this.latchTableModel);        ///fileTableView        this.fileTableModel = FXCollections.observableArrayList();        TableColumn<Tuple<Integer, String>, String> fd = new TableColumn<>("File descriptor");        TableColumn<Tuple<Integer, String>, String> fn = new TableColumn<>("File name");        fd.setCellValueFactory(new Callback<TableColumn.CellDataFeatures<Tuple<Integer, String>, String>, ObservableValue<String>>() {            @Override            public ObservableValue<String> call(TableColumn.CellDataFeatures<Tuple<Integer, String>, String> param) {                return new SimpleStringProperty(String.valueOf(param.getValue().getFirst()));            }        });        fn.setCellValueFactory(new Callback<TableColumn.CellDataFeatures<Tuple<Integer, String>, String>, ObservableValue<String>>() {            @Override            public ObservableValue<String> call(TableColumn.CellDataFeatures<Tuple<Integer, String>, String> param) {                return new SimpleStringProperty(String.valueOf(param.getValue().getSecond()));            }        });        this.fileTableView.getColumns().setAll(fd, fn);        this.fileTableView.setItems(this.fileTableModel);        TableColumn<Tuple<String, Integer>, String> symNameColumn = new TableColumn<>("Symbol name");        TableColumn<Tuple<String, Integer>, String> symValueColumn = new TableColumn<>("Value");        symNameColumn.setCellValueFactory(new Callback<TableColumn.CellDataFeatures<Tuple<String, Integer>, String>, ObservableValue<String>>() {            @Override            public ObservableValue<String> call(TableColumn.CellDataFeatures<Tuple<String, Integer>, String> param) {                return new SimpleStringProperty(param.getValue().getFirst());            }        });        symValueColumn.setCellValueFactory(new Callback<TableColumn.CellDataFeatures<Tuple<String, Integer>, String>, ObservableValue<String>>() {            @Override            public ObservableValue<String> call(TableColumn.CellDataFeatures<Tuple<String, Integer>, String> param) {                return new SimpleStringProperty(String.valueOf(param.getValue().getSecond()));            }        });        this.symTableView.getColumns().setAll(symNameColumn, symValueColumn);        this.symTableModel = FXCollections.observableArrayList();        this.symTableView.setItems(this.symTableModel);        // outListView        this.outListModel = FXCollections.observableArrayList();        this.outListView.setItems(this.outListModel);        this.prgStateListView.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<PrgState>() {            @Override            public void changed(ObservableValue<? extends PrgState> observable, PrgState oldValue, PrgState newValue) {                prgIdLabel.setText(String.valueOf(newValue.getId()));                List<PrgState> prgStates = prgStateService.getAll();                PrgState current = prgStates.stream().filter(e->e.getId() == Integer.valueOf(prgIdLabel.getText())).findFirst().get();                List<IStmt> list = current.getExeStack().toStack().stream().collect(Collectors.toList());                Collections.reverse(list);                exeStackModel.setAll(list);                symTableModel.setAll(current.getSymTable().clone().toMap().entrySet().stream().map(e->new Tuple<String, Integer>(e.getKey(), e.getValue())).collect(Collectors.toList()));            }        });        // exeStack        this.exeStackModel = FXCollections.observableArrayList();        this.exeStackListView.setItems(this.exeStackModel);        this.update(this.prgStateService);    }    Map<Integer, Integer> conservativeGarbageCollector(Collection<Integer> symTableValues, Map<Integer, Integer> heap) {        return heap.entrySet()                .stream()                .filter(e->symTableValues.contains(e.getKey()))                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));    }    public List<PrgState> removeCompletedPrg(List<PrgState> prgStateList) {        return prgStateList.stream()                .filter(p -> p.isNotCompleted())                .collect(Collectors.toList());    }    public void setMain(PrgState state) {        this.rep.getPrgList().clear();        this.rep.getPrgList().add(state);    }    public void serialize() {        this.rep.serialize();    }    public void deserializa() {        this.rep.deserialize();    }    private void createAlertFromException(Exception ex) {        System.out.println(ex);        Alert alert = new Alert(Alert.AlertType.ERROR);        alert.setTitle("Exception Dialog");        alert.setHeaderText("Program State Exception Dialog");        alert.setContentText("There was an exception:\n" + ex.getMessage());        // Create expandable Exception.        StringWriter sw = new StringWriter();        PrintWriter pw = new PrintWriter(sw);        ex.printStackTrace(pw);        String exceptionText = sw.toString();        Label label = new Label("The exception stacktrace was:");        TextArea textArea = new TextArea(exceptionText);        textArea.setEditable(false);        textArea.setWrapText(true);        textArea.setMaxWidth(Double.MAX_VALUE);        textArea.setMaxHeight(Double.MAX_VALUE);        GridPane.setVgrow(textArea, Priority.ALWAYS);        GridPane.setHgrow(textArea, Priority.ALWAYS);        GridPane expContent = new GridPane();        expContent.setMaxWidth(Double.MAX_VALUE);        expContent.add(label, 0, 0);        expContent.add(textArea, 0, 1);        alert.getDialogPane().setExpandableContent(expContent);        alert.showAndWait();    }    public void oneStepForAllPrg(List<PrgState> prgList) throws InterruptedException {        /// Log the states before the execution        prgList.forEach(prg -> {            try {                rep.logPrgStateExec(prg);            } catch (IOException e) {                e.printStackTrace();            }        });        List<Callable<PrgState>> callList = prgList.stream()                .map((PrgState p) -> (Callable<PrgState>)(() -> {return p.oneStep();}))                .collect(Collectors.toList());        List<PrgState> newPrgList = executor.invokeAll(callList).stream()                .map(future -> {                    try {                        return future.get();                    } catch (Exception ex) {                        createAlertFromException(ex);                        /*                        System.out.println(ex);                        Alert alert = new Alert(Alert.AlertType.ERROR);                        alert.setTitle("Exception Dialog");                        alert.setHeaderText("Program State Exception Dialog");                        alert.setContentText("There was an exception: " + ex.getMessage());                        // Create expandable Exception.                        StringWriter sw = new StringWriter();                        PrintWriter pw = new PrintWriter(sw);                        ex.printStackTrace(pw);                        String exceptionText = sw.toString();                        Label label = new Label("The exception stacktrace was:");                        TextArea textArea = new TextArea(exceptionText);                        textArea.setEditable(false);                        textArea.setWrapText(true);                        textArea.setMaxWidth(Double.MAX_VALUE);                        textArea.setMaxHeight(Double.MAX_VALUE);                        GridPane.setVgrow(textArea, Priority.ALWAYS);                        GridPane.setHgrow(textArea, Priority.ALWAYS);                        GridPane expContent = new GridPane();                        expContent.setMaxWidth(Double.MAX_VALUE);                        expContent.add(label, 0, 0);                        expContent.add(textArea, 0, 1);                        // Set expandable Exception into the dialog pane.                        alert.getDialogPane().setExpandableContent(expContent);                        alert.showAndWait();                        */                    }                    return null;                })                .filter(p -> p != null)                .collect(Collectors.toList());        prgList.addAll(newPrgList);        prgList.forEach(prg -> {            try {                rep.logPrgStateExec(prg);            } catch (IOException e) {                e.printStackTrace();            }        });        rep.setPrgList(prgList);        this.prgStateService.notifyObservers();    }    public void allSteps() throws UnknownVariableException, DivideByZeroException, FileAlreadyOpenedException, FileNotOpenedException, IOException, UnknownComparisonExpression, InterruptedException {        executor = Executors.newFixedThreadPool(2);        while(true) {            List<PrgState> prgList = removeCompletedPrg(this.prgStateService.getAll());            if(prgList.size() == 0)                break;            oneStepForAllPrg(prgList);        }        executor.shutdownNow();    }    @FXML    public void allStepsGUI() throws UnknownVariableException, DivideByZeroException, FileAlreadyOpenedException, FileNotOpenedException, IOException, UnknownComparisonExpression, InterruptedException {        executor = Executors.newFixedThreadPool(2);        while(true) {            this.prgStateService.notifyObservers();            List<PrgState> prgList = removeCompletedPrg(this.prgStateService.getAll());            if(prgList.size() == 0) {                System.out.println("FINISHED");                break;            }            oneStepForAllPrg(prgList);            System.out.println("ONE STEP");            break;        }        executor.shutdownNow();    }    @Override    public void update(Observable<PrgState> observable) {        List<PrgState> prgStates = this.prgStateService.getAll();        this.prgStatesCnt.setText(String.valueOf(prgStates.size()));        this.prgStateModel.setAll(prgStates);        this.outListModel.setAll(this.prgStateService.getOutList());        this.heapTableModel.setAll(this.prgStateService.getHeapList());        //latchtable        this.latchTableModel.setAll(this.prgStateService.getLatchList());        this.fileTableModel.setAll(prgStates.get(0).getFileTable().keys()                .stream()                .map(k -> new Tuple<Integer, String>(k, prgStates.get(0).getFileTable().get(k).getFirst()))                .collect(Collectors.toList())        );        this.fileTableModel.stream().map(e->String.valueOf(e.getFirst()) + e.getSecond()).forEach(System.out::println);        PrgState current = prgStates.stream().filter(e->e.getId() == Integer.valueOf(prgIdLabel.getText())).findFirst().get();        List<IStmt> list = current.getExeStack().toStack().stream().collect(Collectors.toList());        Collections.reverse(list);        this.exeStackModel.setAll(list);        this.symTableModel.setAll(current.getSymTable().clone().toMap().entrySet().stream().map(e->new Tuple<String, Integer>(e.getKey(), e.getValue())).collect(Collectors.toList()));    }}